# 10장 테스트 코드와 유지보수

## 테스트 코드와 유지보수

지속적으로 코드를 통합하고 출시 가능한 상태로 만들고 배포하려면 새로 추가한 코드가 기존 기능을 망가뜨리지 않는지 확인할 수 있어야 하며 이런 이유로 자동화 테스트는 CI/CD의 필수 요건 중 하나다.

테스트 코드는 그 자체로 코드기 때문에 제품 코드와 동일하게 유지보수 대상이 된다.  
테스트 코드를 유지보수하는데 시간이 많이 들기 시작하면 점점 테스트 코드를 손보지 않아 실패하는 테스트가 증가하게 된다.

**깨진 유리창 이론**  
깨진 테스트가 발견되면 즉시 수정해서 테스트 실패가 확산되는 것을 방지해야 한다.

## 변수나 필드를 사용해서 기댓값 표현하지 않기

## 두 개 이상을 검증하지 않기

한 테스트 메소드에서 서로 다른 내용을 검증한다면 각 검증 대상을 별도로 분리해서 테스트의 집중도를 높일 수 있다.

## 정확하게 일치하는 값으로 모의 객체 설정하지 않기

모의 객체는 가능한 범용적인 값을 사용해서 기술해야 한다.

## 과도하게 구현 검증하지 않기

내부 구현을 검증하는 것이 나쁜 것은 아니지만 구현을 조금만 변경해도 테스트가 깨질 가능성이 커진다는 단점이 있다.

내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다.

## 셋업을 이용해서 중복된 상황을 설정하지 않기

중복된 코드를 제거하기 위해 @BeforeEach 메소드를 이용해서 상황을 구성할 수 있다.

셋업을 활용하면 시간이 지난 후 기억나지 않아서 코드를 위아래로 이동하면서 실패한 원인을 분석해야 한다.

테스트 메소드는 자체적으로 검증하는 내용을 완전히 기술하고 있어야 테스트 코드를 유지보수하는 노력을 줄일 수 있다.

### 통합 테스트에서 데이터 공유 주의하기

통합 테스트 코드를 만들 때는 다음의 두 가지로 초기화 데이터를 나눠서 생각해야 한다.  
* 모든 테스트가 같은 값을 사용하는 데이터
* 테스트 메소드에서만 필요한 데이터

### 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기

테스트 메소드에서 직접 상황을 구성하면서 코드 중복을 없애는 방법이 있는데 그것은 바로 상황 설정을 위한 보조 클래스를 사용하는 것이다.

상황 설정과 동일하게 결과 검증을 위한 보조 클래스를 만들어 테스트 코드를 유지보수하기 좋은 코드로 만들 수 있다.

## 실행 환경이 다르다고 실패하지 않기

같은 테스트 메소드가 실행 환경에 따라 성공하거나 실패하면 안 된다.

간혹 특정 OS 환경에서만 실행해야 하는 테스틑 `@EnabledOnOs`, `@DisabledOnOS` 를 사용한다.

## 실행 시점이 다르다고 실패하지 않기

TestBizClock 클래스를 이용하면 테스트 코드의 시간을 원하는 시점으로 제어할 수 있다.

### 랜덤하게 실패하지 않기

랜덤하게 생성한 값이 결과 검증에 영향을 준다면 구조를 변경해야 테스트가 가능하다.

## 필요하지 않은 값은 설정하지 않기

검증에 필요한 값만 지정한다.

테스트에 필요한 값만 설정하면 필요하지 않은 값을 설정하느라 고민할 필요가 없다.  
또한, 테스트 코드가 짧아져서 한눈에 내용을 파악할 수 있다.

### 단위 테스트를 위한 객체 생성 보조 클래스

테스트를 위한 객체 생성 클래스를 따로 만들면 이런 복잡함을 줄일 수 있다.

## 조건부로 검증하지 않기

조건에 대한 단언도 추가해야 한다.

## 통합 테스트는 필요하지 않은 범위까지 연동하지 않기

`@SpringBootTest`를 사용하면 DB 관련된 설정 외에 나머지 설정도 처리하므로 스프링을 초기화하는 시간이 길어질 수 있다.

## 더 이상 쓸모 없는 테스트 코드

쓸모없는 테스트 코드 역시 실제 코드 유지보수에는 아무 도움이 되지 않으므로 삭제한다.
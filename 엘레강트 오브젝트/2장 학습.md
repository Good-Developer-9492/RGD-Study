# 2장 학습

## 1. 가능하면 적게 캡슐화하세요

4개 또는 그 이하의 객체를 캡슐화할 것을 권장한다.  
~~세계 안의 객체를 바라보는 우리의 사고방식으로 4개 이상의 요소로 구성된 조표를 이해하는 것은 너무나도 어렵다.~~

상태 없는 객체는 존재해서는 안되고, 상태는 객체의 식별자여야 한다.

더 많은 객체가 필요하다면, 클래스를 더 작은 클래스들로 분해해야 한다.

## 2. 최소환 뭔가는 캡슐화하세요

너무 많이 캡슐화하는 방식도 좋지 않지만, 아무것도 캡슐화하지 않는 방식 또한 바람직하지 않다.

객체가 자기 자신을 식별할 수 있도록 다른 객체들을 캡슐화해야 한다.

## 3. 항상 인터페이스를 사용하세요

객체들이 서로를 필요로 하기 때문에 결합된다.

애플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 분리해야한다.  
**객체 분리**란, 상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만든다는 것이다.  
이를 가능하게 하는 가장 훌륭한 도구가 **인터페이스**다.

인터페이스는 우리의 객체가 다른 객체와 의사소통하기 위해 따라야하는 계약이다.

인터페이스를 이용하면 클래스를 느슨하게 분리할 수 있다. 클래스의 내부 구현을 변경하거나 인터페이스의 구현체를 변경하여도 아무 영향이 없다.

클래스 안의 모든 퍼블릭 메소드가 인터페이스를 구현하도록 만들어야 한다.

## 4. 메소드 이름을 신중하게 선택하세요
빌더(Builder)의 이름은 명사로, 조정자(Manipulator)의 이름은 동사로 짓는 것을 추천한다. 빌더는 어떤 것을 만들고, 조정자는 무언가를 조작한다.

빌더란, 무언가를 만들고 새로운 객체를 반환하는 메소드를 가리킨다. 항상 무언가를 반환하기 때문에 반환타입이 절대 void가 될 수 없으며, 이름은 항상 명사여야 한다.

조정자란, 객체로 추상화한 실세계 엔티티를 수정하는 메소드를 의미한다. 조정자의 반환타입은 항상 void이고, 이름은 항상 동사이다.

개념적으로 빌더와 조정자 사이에는 어떤 메서드도 존재해서는 안된다. 즉, 뭔가를 조작한 후 반환하거나, 뭔가를 만드는 동시에 조작하는 메서드가 있어서는 안된다는 것이다.

메소드의 이름을 동사로 지을때는 객체에게 무엇을 할 지 알려줘야 한다.

오직 빌더만이 값을 변환할 수 있고 이름은 명사다.  
객체가 뭔가를 조정해야 한다면 이름은 동사이고 변환값이 없습니다.

객체에게 어떤 일을 해야 하는 지를 직접적으로 이야기하지 않는다. 특정한 계약을 준수하는 결과를 요청할 뿐이다

요약하자면,  
먼저 메소드의 목적이 무엇인지 확인해야 한다.  
메소드는 빌더나 조정자 둘 중 하나여야 한다.  
결코 빌더인 동시에 조정자여서는 안된다.  
빌더라면 이름을 명사로, 조정자라면 이름을 동사로 지어야 한다.

## 5. 퍼블릭 상수를 사용하지 마세요
상수를 사용하는 이유는 데이터를 공유하기 위해서다.  
객체들은 어떤 것도 공유해서는 안된다. 대신 독립적이어야 하고 닫혀있어야 한다.  
상수를 이용한 공유 메커니즘은 캡슐화에 객체지향적인 사고 전체를 부정하는 일이다.

OOP에는 객체가 존재하기 때문에 퍼블릭 상수를 이용해서 중복 문제를 해결하는 것은 매우 잘못된 접근 방법이다.  
Java에서는 Constants 클래스의 가시성이 public이기 때문에 클래스 로더에 의해 로딩된 모든 클래스들이 상수에 접근할 수 있다.

코드 중복이라는 문제를 해결하기 위해 결합도가 높아지고, 응집도가 낮아지는 두 개의 문제가 발생한다.  

5.1 결합도 증가  
두 클래스는 모두 같은 객체에 의존하고 있으며, 이 의존성은 하드 코딩되어 있다.  

5.2 응집도 저하  
낮은 응집도는 객체가 자신의 문제를 해결하는데 덜 집중한다는 것을 의미한다.

대안  
객체 사이에 데이터를 중복해서는 안된다. 상수를 사용하지 않고 새로운 클래스를 사용하여 문제를 해결할 수 있다.  
둘의 코드가 다르지 않다고 생각할 수 있지만, 새로운 클래스에 대한 결합은 계약을 통해 추가된 것이며 계약에 의한 결합은 언제라도 분리가 가능하기 때문에 유지보수성을 저하시키지 않는다.

## 6. 불변 객체로 만드세요
모든 클래스를 상태 변경이 불가능한 불변 클래스로 구현하면 유지보수성을 크게 향상시킬 수 있다. 불변성은 크기가 작고, 응집력이 높으며, 느슨하게 결합되고, 유지보수하기 쉬운 클래스를 만들 수 있도록 한다.

불변 객체는 어떤 방식으로든 자기 자신을 수정할 수 없다.

가변 객체의 사용을 엄격하게 금지해야 한다.

불변성을 지지하는 이유

식별자 가변성 문제가 없다.  
동일해 보이는 두 객체를 비교한 후 한 객체의 상태를 변경할 때, 두 객체는 더 이상 동일하지 않지만 우리는 여전히 두 객체가 동일하다고 생각하는 문제  
불변 객체를 사용하면 상태 변경이 불가능하기 때문에 문제가 발생하지 않는다.

실패 원자성  
완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능한 특성이다.  
객체의 상태 변경중 Exception이 발생하면 객체의 일부만 변경되고 나머지는 원래 값을 유지할 수 있다. 불변 객체는 내부의 어떤 것도 수정할 수 없기 때문에 이런 결함이 발생하지 않는다. 대신 새로운 상태를 가진 새로운 객체를 인스턴스화한다.

시간적 결합을 제거할 수 있다.  
불변 객체를 사용하면 인스턴스화와 초기화를 분리시킬 수 없고 항상 함께 실행되어야 한다.  
객체를 사용해서 어떤 일을 수행하려면 그 전에 객체를 완전한 상태로 초기화해야 한다.  
그 후에 어떤 일이 일어나는 지는 중요하지 않습니다. 객체는 자족적이면서도 견고하다.

사이드이펙트 제거  
불변 객체를 사용하면 어떤 누구도 객체를 수정할 수 없어서 객체의 상태가 변하지 않았다고 확신할 수 있다.  
코드가 제대로 동작하지 않는 경우에도 사이드이펙트가 발생한 위치를 찾을 필요가 없다.  
불변성으로 인해 객체가 언제 어디서든 동일한 의미를 가진다고 확신할 수 있기 때문이다.

NULL 참조 없애기  
NULL을 참조하는 객체는 언제 객체가 유효한 상태이고 언제 객체가 아닌 다른 형태로 바뀌는 지를 이해하기 어렵기 때문에 유지보수성이 저하될 수 밖에 없다.  
불변 객체를 사용하면 NULL을 포함시키는 것이 애초에 불가능해진다.  
작고, 견고하고, 응집도 높은 객체를 생성할 수 밖에 없도록 강제되기 때문에 결과적으로 유지보수하기 더 쉬운 객체를 만든다.

스레드 안정성  
여러 스레드에서 동시에 사용될 수 있으며 그 결과를 항상 예측가능하도록 유지할 수 있는 객체의 품질을 의미한다.  
병행성 이슈는 발견하고 디버깅하고 해결하기 가장 어려운 문제 중 하나다. 불변 객체는 실행 시점에 상태를 수정할 수 없게 금지함으로써 이 문제를 완벽하게 해결한다.  
가변 클래스 역시 스레드에 안전하게 만들수는 있지만, 생각처럼 쉽지 않고 동기화 로직을 추가하는 일은 성능상의 비용을 초래한다. 각 스레드는 객체를 배타적으로 잠그기 때문에 다른 모든 스레드는 객체가 해제될 때까지 기다릴 수 밖에 없다.

단순성 객체가 단순해질수록 응집도는 높아지고 유지보수하기는 더 쉬워진다.  
대부분의 경우 단순하다는 것은 더 적은 코드 라인수를 의미한다.  
저자가 생각하는 Java 클래스의 최대 크기는 주석과 공백을 포함해서 250줄 정도

## 7. 문서를 작성하는 대신 테스트를 만드세요
문서화는 유지보수에 있어 중요한 구성요소다.

단위 테스트는 클래스의 사용 방법을 보여주는데 반해, 문서는 이해하고 해석하기 어려운 이야기를 들려준다.

코드를 문서화하는 대신 코드를 깔끔하게 만들기 바란다.  
깔끔하고 유지보수 가능한 단위 테스트를 추가하면, 클래스를 더 깔끔하게 만들 수 있고 유지보수성을 향상시킬 수 있다.

## 8. 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요
Mocking, 테스트를 최적화하기 위한 도구  
Fake, 인터페이스의 일부이며 인터페이스와 함께 제공

Fake 클래스를 사용하면 테스트를 더 짧게 만들 수 있기 때문에 유지보수성이 향상된다.  Mocking은 테스트가 매우 장황해지고 이해하거나 리팩토링하기 어려워진다.

Mocking은 클래스 구현과 관련된 내부의 세부사항을 테스트와 결합시킨다. 가정하고, 가정을 모의 객체 안에 하드코딩한 채 작업을 끝내버린다.  
Fake 클래스는 테스트를 충분히 유지보수 가능하게 만들 수 있다. 두 클래스 사이의 의사소통 방식에 대해서 신경쓸 필요가 없기 때문이다.

여러분이 만드는 인터페이스부터 Fake 클래스들을 함께 제공하기 바란다.

## 9. 인터페이스를 짧게 유지하고 스마트를 사용하세요
클래스가 다수의 인터페이스를 구현하기 때문에, 인터페이스를 작게 만드는 것이 클래스를 작게 만드는 것보다 더 중요하다.

인터페이스를 구현하는 서로 다른 클래스 안에 동일한 기능을 반복해서 구현하고 싶지 않을때, 스마트 클래스를 인터페이스와 함께 제공할 수 있다.

데코레이터가 스마트 클래스와 다른 점은 스마트 클래스가 객체에 새로운 메소드를 추가하는데 비해 데코레이터는 이미 존재하는 메소드를 좀 더 강력하게 만든다는 점이다.
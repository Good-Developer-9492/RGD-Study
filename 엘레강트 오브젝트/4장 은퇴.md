# 4장 은퇴

## 1. 절대 NULL을 반환하지 마세요

문제는 객체에 대한 신뢰가 무너진다는 사실이다.  
반환된 값이 객체인지부터 확인해야 하기 때문에, 객체에게 작업을 요청한 후 안심하고 결과에 의지할 수 없다.  
이는 곧 유지보수성의 심각한 손실로까지 이어진다.

### 1.1 빠르게 실패하기 vs 안전하게 실패하기

안전하게 실패하기  
버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 노력을 기울일 것을 권장하는 방법   

빠르게 실패하기  
문제가 발생하면 곧바로 실행을 중단하고 최대한 빨리 예외를 던지는 방법  

저자는 빠르게 실패하기의 지지자로, 에러를 발견한 즉시 보고하는 경우에만 안전성과 견고함을 얻을 수 있다고 생각한다.  
더 빠르게 문제를 찾을수록 더 빠르게 실패하고, 결과적으로 전체적인 품질이 향상된다고 보는 것이다.

### 1.2 NULL의 대안

첫 번째 방법은 메소드를 두 개로 나누는 방법  
두 개의 메소드로 나누어 하나는 객체의 존재를 확인하고, 다른 하나는 객체를 반환하는 방법이다.  

두 번째 방법은 객체 컬랙션을 대신 반환하는 방법  
Optional과 같은 유사한 도구를 사용하는 방법

마지막 방법으로 NULL 객체 디자인 패턴
NULL 객체 패턴에서는 원하는 객체를 발견하지 못할 경우, 겉으로 보기에는 원래의 객체처럼 보이지만 실제로는 다르게 행동하는 객체를 반환한다.

결론적으로, 찾지 못한 뭔가를 반환할 필요가 있다면 NULL 대신 예외를 던지거나 컬렉션을 반환하거나 널 객체를 반환하라.

## 2. 체크 예외만 던지세요

throws를 선언함으로써 문제를 처리할 책임을 상위 레벨로 넘길 수 있다.

언체크 예외를 사용하면 메소드를 호출하는 쪽에서 어떤 예외가 던져질 지 예상할 수 없다.  언체크 예외의 경우 예외의 타입을 선언하지 않아도 무방한 반면에 체크 예외는 항상 예외의 타입을 공개해야 한다.

### 2.1 꼭 필요한 경우가 아니라면 예외를 잡지 마세요

메소드를 설계할 때 모든 예외를 잡아서 메소드를 안전하게 만들지, 아니면 상위로 문제를 전파할지를 명확하게 선택해야 한다.

분기를 처리하기 위해 if문을 사용하는 것은 적절하지만, 예외는 분기를 위한 도구가 아니다. 예외를 잡아 상황을 구조하는 일은 매우 정당한 이유가 있을 경우에만 용인되는 매우 중요한 행동이다.

### 2.2 항상 예외를 체이닝하세요

예외를 잡은 즉시 새로운 예외를 던지는 예외 체이닝이 있다. 원래의 문제를 새로운 문제로 감싸서 상위로 던진다.  
핵심은 문제를 발생시켰던 낮은 수준의 근본 원인을 소프트웨어의 더 높은 수준으로 이동시켰다는 점이다.  
원래의 문제를 무시하면 근본 원인에 관한 매우 가치있는 정보가 손실되기 때문에 좋지않다.

## 3. final이거나 abstract이거나

우리가 원하는 것은 상속을 완전히 제거하는 것이 아니라 올바르게 사용하는 것이다.  
문제를 일으키는 주범은 가상 메소드이다.

기본적으로 클래스가 가질 수 있는 신분에는 세 가지가 있다. final이거나 abstract이거나, 둘 중 어느쪽도 아니거나.  
final 클래스는 사용자 관점에서 블랙 박스다. 상속을 통해 수정할 수 없고 불투명하고 독립적이며 자신이 어떻게 행동해야 하는지 알고 있고 어떤 도움도 필요로 하지 않는다. 기술적으로 final 클래스 안의 어떤 메소드도 오버라이딩할 수 없다. 메소드는 영원히 final입니다.  
abstract 클래스는 글래스 박스이고 불완전하다. 스스로 행동할 수 없기 때문에 누군가의 도움이 필요하며 일부 요소가 누락되어 있다. 기술적으로 abstract 클래스의 특정 메소드를 오버라이딩할 수 있지만 다른 메소드는 모두 final이다.  
final도 abstract도 아닌 클래스는 둘 중 어느쪽도 될 수 있기 때문에 매우 혼란스럽다. 

우리는 의도를 명확히 표현해야 한다. 메소드는 올바른 방식으로 설계하거나, 아니면 아예 설계하지 말아야 한다. 그 사이에 어떤 것도 있어서는 안된다.
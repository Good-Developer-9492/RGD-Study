# 3장 취업

## 1. 5개 이하의 public 메소드만 노출하세요

가장 우아하고, 유지보수가 가능하고, 응집력이 높으면서, 테스트하기도 용이한 객체는 작은 객체다.

여기에서 말하는 public 메소드에는 protected 메소드도 포함된다.

클래스를 작게 만들면 우아함, 유지보수성, 응집도, 테스트 용이성이 향상된다.  
클래스가 더 작을수록 실수할 가능성이 줄어들기 때문에 작은 클래스는 더 우아하다.  
더 작은 클래스는 유지보수하기도 쉽다. 코드양이 더 적고, 메소드의 수가 더 적고, 에러를 찾기 더 쉽고, 수정하기도 더 쉽다. 각각의 메소드가 객체의 진입점이고 진입점의 수가 적다면 문제를 더 쉽게 고립시킬 수 있다.  
클래스가 작으면 메소드와 프로퍼티가 더 가까이 있을 수 있기 때문에 응집도가 높아진다.  

## 2. 정적 메소드를 사용하지 마세요

더 나은 방식은 정적 메소드 대신 객체를 사용하는 것이다.

정적 메소드는 소프트웨어를 유지보수하기 어렵게 만든다.

### 2.1 객체 vs 컴퓨터 사고

함수형, 논리형, 객체지향 프로그래밍이 절차적 프로그램오가 차별화되는 점이 바로 'is a' 이다.

객체지향적으로 생각하기에서 우리는 그저 누가 누구인지만 정의하고 객체들이 필요할 때 스스로 상호작용하도록 제어를 위임한다.

### 2.2 선언형 스타일 vs 명령형 스타일

명령형 프로그래밍에서는 '프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술'한다.  
선언형 프로그래밍에서는 '제어 흐름을 서술하지 않고 계산 로직을 표현'한다.

정적 메소드를 사용하든, 객체를 사용하든 여전히 어딘가에서는 if문이 참인지를 확인해야 한다.  
하지만 둘 사이의 차이점은 다른 클래스, 객체, 메소드가 이 기능을 사용하는 방법에 있다.

선언형 프로그래밍을 정의할 때 언급한 것처럼, 제어를 서술하지 않고 로직만 표현한다.

선언형 방식은 더 빠르다.  
선언형 방식에서는 우리가 직접 성능 최적화를 제어할 수 있기 때문이다.  
실행 관점에서 선언형 방식이 더 최적화되기 때문에 더 빠르다는 사실이다.  
최적화 관점에서 직접 통제할 수 있는 코드가 많을수록 유지보수하기도 더 쉬워진다.

선언형 방식이 더 좋은 두 번째 이유는 다형성 때문이다.   
다형성이란 코드 블록 사이의 의존성을 끊을 수 있는 능력을 말한다.

객체를 다른 객체로부터 완전히 분리하기 위해서는 메소드나 주 생성자 어디에서도 new 연산자를 사용하지 말아야 한다.

선언형 프로그래밍을 이용하면 객체 사이의 결합도를 낮출 수 있을 뿐만 아니라, 이 작업을 우아하게 처리할 수도 있다. 두 말할 필요 없이 더 낮은 결합도는 더 나은 유지보수성으로 이어진다.

선언형 방식이 더 좋은 세 번째 이유는 표현력 때문이다.  
코드에는 구현과 관련된 세부 사항은 감춰져 있고, 오직 행동만 표현되어 있다.  

명령형 스타일이 알고리즘과 실행을 다루는 방법이라면, 선언형 스타일은 정확하게 객체와 행동에 관한 방법이다.

네 번째 이유는 코드 응집도 때문이다.  
책임지는 모든 코드들은 한 곳에 뭉쳐 있기 때문에 실수로라도 분리할 수 없다.

### 2.3 유틸리티 클래스

유틸리티 클래스를 구현할 때는 클래스의 인스턴스가 생성되는 것을 방지하기 위해 주 생성자를 private으로 선언하는 것이 좋다.

### 2.4 싱글톤 패턴

싱글톤은 유명한 디자인패턴이지만, 사실 끔찍한 안티 패턴이다.

캡슐화된 객체를 변경할 수 있기 때문에 싱글톤이 유틸리티 클래스보다는 더 좋다.  
유틸리티 클래스 안에는 객체가 존재하지 않기 때문에 어떤 것도 변경할 수 없다. 유틸리티 클래스는 분리할 수 없는 하드코딩된 의존성이다.

논리적인 관점과 기술적인 관점 모두에서 싱글톤은 전역 변수 그 이상도 그이하도 아니다.

캡슐화를 사용하는 것이 대안이 될 수 있다.

### 2.5 함수형 프로그래밍

FP보다 OOP의 표현력이 더 뛰어나고 강력하다.  
FP에서는 오직 함수만 사용할 수 있지만, OOP에서는 객체와 메소드를 조합할 수 있다.

이상적인 OOP 언어에는 클래스와 함께 함수가 포함되어야 한다.

### 2.6 조합 가능한 데코레이터

조합 가능한 데코레이터는 그저 다른 객체를 감싸는 객체일 뿐이다.  
이것은 유명한 디자인 패턴인 데코레이터일 뿐이지만, 이 데코레이터 객체들을 다중계층 구조로 구성하기 시작하면 조합가능해진다.

객체를 어떻게 만들었는지를 전혀 설명하지 않고도 이 객체가 무엇인지 설명할 수 있다.  
단지 선언했을 뿐인데 말이다.

## 3. 인자의 값으로 NULL을 절대 허용하지 마세요

인자의 값으로 NULL을 허용하면 NULL을 체크하는 비교문을 사용할 수 밖에 없다.  
객체가 맡아야 하는 상당량의 책임을 빼앗게 된다.  
우리는 외부에서 자신의 데이터를 다뤄주기만을 기대하고 스스로를 책임질 수 없는 멍청한 자료구조로 객체를 퇴화시키고 있는 것이다.

메소드의 인자로 전달할 값이 없다면 비어있는 것처럼 행동하는 객체를 전달하면 된다.

NULL확인 로직으로 코드를 오염시켜서는 안된다.

## 4. 충성스러우면서 불변이거나, 아니면 상수이거나

불변객체와 가변객체의 중요한 차이는 불변 객체에는 식별자가 존재하지 않으며, 절대로 상태를 변경할 수 없다는 점이다.  
좀 더 정확하게 말해서 불변 객체의 식별자는 객체의 상태와 완전히 동일하다.

어떤 종류의 시스템이라도 전체적으로 불변 객체를 이용해서 설계될 수 있고 설계되어야 한다.

## 5. 절대 getter와 setter를 사용하지 마세요

setter가 존재하는 클래스는 가변 클래스다.

### 5.1 객체 vs 자료구조

클래스는 어떤 식으로든 멤버에게 접근하는 것을 허용하지 않는다. 게다가 자신의 멤버를 노출하지도 않는다.  
우리가 할 수 있는 일이라고는 객체에게 자기 자신을 print()하라고 요청하는 것 뿐이다.  
print()가 어떤 방식으로 동작하는 지도 알 수 없고, 캡슐화된 어떤 멤버가 이 작업에 개입하는 지도 알 수 없다.  
이것이 바로 캡슐화이며, OOP가 지향하는 가장 중요한 설계 원칙 중 하나이다.

모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다.  
특정한 시점에 이해해야 하는 범위가 작을수록, 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기도 쉬워진다.

### 5.2 좋은 의도, 나쁜 결과

요점은 getter와 setter를 사용하면 OOP의 캡슐화 원칙을 손쉽게 위반할 수 있다는 점이다.

## 6. 부 생성자 밖에서는 new를 사용하지 마세요

```java
class Cash {
    private final int dollars;

    public int euro() {
        return new Exchange().rate("USD", "EUR") * this.dollars;
    }
}
```
하드코딩된 의존성  
Cash 클래스는 Exchange 클래스에 직접 연결되어 있기 때문에 의존성을 끊기 위해서는 Cash 클래스의 내부 코드를 변경할 수 밖에 없다.

오직 생성자를 통해 제공된 Exchange와만 협력할 수 있어야 한다. Cash 클래스는 더 이상 Exchage 클래스에 의존하지 않는다.  
다시말해서, 객체가 필요한 의존성을 직접 생성하는 대신, 우리가 생성자를 통해 의존성을 주입한다.

```java
class Cash {
    private final int dollars;
    private final Exchange exchange;
    
    Cash(int value) { // 부 생성자
        this(value, new NYSE());
    }

    Cash(int value, Exchange exchange) { // 주 생성자
        this.dollars = value;
        this.exchange = exchange;
    }
    
    public int euro() {
        return this.exchange.rate("USD", "EUR") * this.dollars;
    }
}
```

## 7. 인트로스펙션과 캐스팅을 피하세요

타입 인트로스펙션은 리플렉션이라는 더 포괄적인 용어로 불리는 여러 가지 기법들 중 하나다.  
리플렉션은 매우 강력한 기법이지만 동시에 코드를 유지보수하기 어렵게 만드는 매우 너저분한 기법이다.